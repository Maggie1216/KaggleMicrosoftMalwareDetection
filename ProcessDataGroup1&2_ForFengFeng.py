# -*- coding: utf-8 -*-
"""
Created on Tue Mar  5 10:45:55 2019

@author: luxiaotong
"""
# -*- coding: utf-8 -*-
"""
Created on Sun Feb 17 12:10:01 2019

@author: luxiaotong
"""
import pandas as pd
import numpy as np

###########Part1: Load and Descriptive Analysis

#LoadData
train_df = pd.read_csv('train.csv')
test_df = pd.read_csv('test.csv')
train_sample=train_df

#GetColumnsFunction
def get_columns(group):
    column_group={
   'ProductName':4,
   'EngineVersion':4,
   'AppVersion':4,
   'AvSigVersion':4,
   'IsBeta':1,
   'RtpStateBitfield':4,
   'IsSxsPassiveMode':1,
   'DefaultBrowsersIdentifier':4,
   'AVProductStatesIdentifier':4,
   'AVProductsInstalled':4,
   'AVProductsEnabled':4,
   'HasTpm':1,
   'CountryIdentifier':4,
   'CityIdentifier':4,
   'OrganizationIdentifier':4,
   'GeoNameIdentifier':4,
   'LocaleEnglishNameIdentifier':4,
   'Platform':4,
   'Processor':4,
   'OsVer':4,
   'OsBuild':4,
   'OsSuite':4,
   'OsPlatformSubRelease':4,
   'OsBuildLab':4,
   'SkuEdition':4,
   'IsProtected':1,
   'AutoSampleOptIn':1,
   'PuaMode':1,
   'SMode':1,
   'IeVerIdentifier':4,
   'SmartScreen':4,
   'Firewall':1,
   'UacLuaenable':1,
   'Census_MDC2FormFactor':3,
   'Census_DeviceFamily':3,
   'Census_OEMNameIdentifier':2,#Was 3
   'Census_OEMModelIdentifier':2,#Was 3
   'Census_ProcessorCoreCount':3,
   'Census_ProcessorManufacturerIdentifier':3,
   'Census_ProcessorModelIdentifier':2,
   'Census_ProcessorClass':3,
   'Census_PrimaryDiskTotalCapacity':2,
   'Census_PrimaryDiskTypeName':3,
   'Census_SystemVolumeTotalCapacity':2,
   'Census_HasOpticalDiskDrive':1,
   'Census_TotalPhysicalRAM':2,#Was 3
   'Census_ChassisTypeName':3,
   'Census_InternalPrimaryDiagonalDisplaySizeInInches':2,
   'Census_InternalPrimaryDisplayResolutionHorizontal':2,
   'Census_InternalPrimaryDisplayResolutionVertical':2,
   'Census_PowerPlatformRoleName':3,
   'Census_InternalBatteryType':3,
   'Census_InternalBatteryNumberOfCharges':3,#Was 2
   'Census_OSVersion':3,#Was 2
   'Census_OSArchitecture':3,
   'Census_OSBranch':3,
   'Census_OSBuildNumber':3,
   'Census_OSBuildRevision':3,
   'Census_OSEdition':3,
   'Census_OSSkuName':3,
   'Census_OSInstallTypeName':3,
   'Census_OSInstallLanguageIdentifier':3,
   'Census_OSUILocaleIdentifier':3,
   'Census_OSWUAutoUpdateOptionsName':3,
   'Census_IsPortableOperatingSystem':1,
   'Census_GenuineStateName':3,
   'Census_ActivationChannel':3,
   'Census_IsFlightingInternal':1,
   'Census_IsFlightsDisabled':1,
   'Census_FlightRing':3,
   'Census_ThresholdOptIn':1,
   'Census_FirmwareManufacturerIdentifier':2,
   'Census_FirmwareVersionIdentifier':2,
   'Census_IsSecureBootEnabled':1,
   'Census_IsWIMBootEnabled':1,
   'Census_IsVirtualDevice':1,
   'Census_IsTouchEnabled':1,
   'Census_IsPenCapable':1,
   'Census_IsAlwaysOnAlwaysConnectedCapable':1,
   'Wdft_IsGamer':1,
   'Wdft_RegionIdentifier':4
    }
    lst=[]
    for i,v in column_group.items():
        if v==group:
            lst.append(i)
    return lst

#Group1: Binary values
sample_group1=train_sample[get_columns(1)]
#WeirdValues
sample_group1['PuaMode']=sample_group1['PuaMode'].replace('on',1)#'on' to 1
sample_group1.loc[sample_group1['UacLuaenable']>1,'UacLuaenable']=np.nan#>1 equals to na
#Drop
drop_features=['IsBeta', 
               'AutoSampleOptIn',
               'PuaMode',
               'Census_IsFlightingInternal', 
               'Census_IsFlightsDisabled', 
               'Census_ThresholdOptIn', 
               'Census_IsWIMBootEnabled'
               ]
sample_group1=sample_group1.drop(drop_features,axis=1)


#Group2: Numeric values
sample_group2=train_sample[get_columns(2)]
#Outliers
##ReplaceOrObservePercentageOurlierFunction
def quantile_outlier(df,column,percent,replace_bool=0):
    upper=df[column].quantile(percent)
    lower=df[column].quantile(1-percent)
    out_u=df[column]>upper
    out_l=df[column]<lower
    out=out_u | out_l
    if replace_bool==0:
        return df[column][out]
    else:
        df[column][out_u]=upper
        df[column][out_l]=lower
quantile_outlier(sample_group2,'Census_PrimaryDiskTotalCapacity',0.99,1)
quantile_outlier(sample_group2,'Census_SystemVolumeTotalCapacity',0.99,1)
quantile_outlier(sample_group2,'Census_InternalPrimaryDiagonalDisplaySizeInInches',0.93,1)
quantile_outlier(sample_group2,'Census_InternalPrimaryDisplayResolutionHorizontal',0.98,1)
quantile_outlier(sample_group2,'Census_InternalPrimaryDisplayResolutionVertical',0.98,1)      
quantile_outlier(sample_group2,'Census_TotalPhysicalRAM',0.99,1)  
#Binning & Normalization
##Binning-QuantileBased
bin_features=['Census_FirmwareManufacturerIdentifier','Census_InternalPrimaryDiagonalDisplaySizeInInches',
              'Census_InternalPrimaryDisplayResolutionHorizontal','Census_InternalPrimaryDisplayResolutionVertical',
              'Census_PrimaryDiskTotalCapacity','Census_TotalPhysicalRAM']
def observe_binning_number(df,column,bins,replace_bool=0):
    bined=pd.qcut(df[column],bins,duplicates='drop',retbins=True)
    df_b=bined[0]
    df_b=pd.DataFrame(df_b,columns=[column])
    df_b.loc[:,'HasDetections']=df['HasDetections']
    if replace_bool==0:
        return print(bined[1])
    else:
        df[column]=df_b[column]
observe_binning_number(sample_group2,column=bin_features[0],bins=9,replace_bool=1)
observe_binning_number(sample_group2,column=bin_features[1],bins=7,replace_bool=1)
observe_binning_number(sample_group2,column=bin_features[2],bins=2,replace_bool=1)
observe_binning_number(sample_group2,column=bin_features[3],bins=5,replace_bool=1)
observe_binning_number(sample_group2,column=bin_features[4],bins=4,replace_bool=1)
observe_binning_number(sample_group2,column=bin_features[5],bins=3,replace_bool=1)
##Normalization
non_bin_features=list(set(get_columns(2))-set(bin_features))
sample_group2[non_bin_features]=(sample_group2[non_bin_features]-sample_group2[non_bin_features].mean())/sample_group2[non_bin_features].std()

